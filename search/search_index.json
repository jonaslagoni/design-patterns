{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-eda-design-patterns-website","title":"Welcome to EDA Design Patterns website","text":"<p>It includes a range of patterns used in EDA with a specific focus on how to design it with AsyncAPI.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Simple roadmap for patterns to document;</p> <ul> <li>[X] Add ECST pattern</li> <li>[X] Add CQRS pattern</li> <li>[X] Basic doc rendering</li> <li>[X] Github pages</li> <li>[X] Event Sourcing</li> <li>[X] Change Data Capture (CDC)</li> </ul> <p>Communication Patterns</p> <ul> <li>[ ] Request-Reply</li> <li>[ ] point-to-point</li> <li>[ ] event streaming</li> <li>[ ] Publish-Subscribe pattern</li> </ul> <p>Consumer Scalability / Patterns</p> <ul> <li>[ ] consumer groups</li> <li>[ ] partitioning</li> <li>[ ] Exclusive Consumer (HA)</li> </ul> <p>Error Handling Patterns</p> <ul> <li>[X] dead letter queue</li> <li>[ ] discard</li> <li>[ ] pause and retry</li> <li>[X] saga</li> </ul>"},{"location":"cdc/","title":"Change Data Capture (CDC) Pattern","text":""},{"location":"cdc/#what-problem-does-cdc-solve","title":"What Problem Does CDC Solve?","text":"<p>In modern systems, data often lives in different places. Keeping all this data up-to-date and consistent can be a big challenge, especially when you need changes to happen in real-time. Traditional methods, like running batch jobs to sync everything, are slow and can lead to problems if data changes frequently.</p> <p>This is where Change Data Capture (CDC) comes in. CDC tracks changes in a database as they happen and sends those changes to other systems. This means everyone always has the latest information, without having to wait for a batch job to run.</p> <p></p>"},{"location":"cdc/#key-concepts-of-cdc","title":"Key Concepts of CDC","text":""},{"location":"cdc/#cdc-producer-source","title":"CDC Producer (Source)","text":"<p>This is the part of the system that keeps an eye on the database for any changes. When something changes\u2014like a new record being added, updated, or deleted\u2014the CDC Producer captures that change and turns it into an event.</p> <ul> <li>What It Does: Watches the database and creates events for any changes.</li> <li>Examples: AWS Database Migration Service (DMS), Apache Debezium.</li> </ul>"},{"location":"cdc/#cdc-consumers-sinks","title":"CDC Consumers (Sinks)","text":"<p>These are the systems that listen for the CDC events. When they get an event, they do something with it\u2014like update their own database, trigger a workflow, or process the data in some way.</p> <ul> <li>What They Do: React to the events by updating data, starting processes, etc. They can also move events from producer to other consumers.</li> <li>Examples: Data warehouses like Redshift, microservices that need consistent data, real-time analytics systems, message brokers (Kafka, Amazon SNS/SQS, RabbitMQ...)</li> </ul>"},{"location":"cdc/#where-cdc-is-used","title":"Where CDC is Used","text":"<p>In event-driven systems, you want things to happen automatically in response to data changes. CDC makes this easy by turning database changes into events that can trigger actions elsewhere. For example, when inventory levels change, CDC can trigger a reorder or notify other systems to take action.</p> <p>CDC also helps with keeping your data consistent across your microservices. In a setup where different services handle different parts of your data, keeping everything consistent can be tricky. CDC helps by making sure that when one service updates its data, all other related services get that update immediately. For example, if a customer updates their profile, CDC ensures that the order service and any other relevant services are instantly aware of that change.</p>"},{"location":"cdc/#example","title":"Example","text":"<p>Let\u2019s say you\u2019re tracking inventory updates. Here\u2019s a simplified way to describe how CDC would work using AsyncAPI:</p> <pre><code>asyncapi: '3.0.0'\ninfo:\n  title: Inventory Management CDC API\n  version: '1.0.0'\n  description: 'API for handling CDC events related to inventory updates.'\n\nservers:\n  production:\n    host: broker.example.com:9092\n    protocol: kafka\n    description: 'Kafka broker for production'\n\nchannels:\n  InventoryCdcUpdates:\n    address: inventory.cdc.updates\n    messages:\n      InventoryUpdateEvent:\n        $ref: '#/components/messages/InventoryUpdateEvent'\n    description: 'Channel for inventory update events'\n\noperations:\n  receiveInventoryUpdates:\n    action: receive\n    channel:\n      $ref: '#/channels/InventoryCdcUpdates'\n    messages:\n      - $ref: '#/channels/InventoryCdcUpdates/messages/InventoryUpdateEvent'\n\ncomponents:\n  messages:\n    InventoryUpdateEvent:\n      name: InventoryUpdateEvent\n      title: 'Inventory Update Event'\n      summary: 'Represents an inventory update in the system'\n      contentType: application/json\n      payload:\n        type: object\n        properties:\n          eventType:\n            type: string\n            enum:\n              - INSERT\n              - UPDATE\n              - DELETE\n          entity:\n            type: string\n            example: 'Inventory'\n          state:\n            type: object\n            description: 'The state of the inventory item after the change'\n            properties:\n              productId:\n                type: string\n                description: 'Unique identifier for the product'\n              stockLevel:\n                type: integer\n                description: 'Current stock level after the update'\n              lastModified:\n                type: string\n                format: date-time\n                description: 'Timestamp when the inventory was last modified'\n</code></pre> <p>    Open in AsyncAPI studio </p>"},{"location":"cdc/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"cdc/#coupling-to-database-schema","title":"Coupling to Database Schema","text":"<p>One common mistake is tying CDC events too closely to your database\u2019s structure. If your database changes\u2014like renaming a column\u2014it could break everything that relies on those events. To avoid this, it\u2019s better to use a logical data model that isn\u2019t directly dependent on the database schema or use a translator.</p>"},{"location":"cdc/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>This can be used in combination with ECST pattern, this enable consumers to update their state or react appropriately without needing to fetch additional data</li> <li>If you are dealing with data consistency issues in a microservice architecture, you can use CDC in combination with the transactional outbox pattern</li> <li>If you are migrating from a monolith application to a microservice you can use the CDC-Based Strangler Fig Pattern </li> </ul>"},{"location":"cdc/#tools","title":"Tools","text":"<ul> <li>Debezium - Open-source, Kafka-based CDC tool.</li> <li>AWS Database Migration Service (DMS) - Managed CDC and database migration service.</li> <li>Oracle GoldenGate - Enterprise-level CDC and data integration tool for Oracle databases.</li> <li>IBM InfoSphere Data Replication (IIDR) - CDC tool for various databases, with a focus on low-latency replication.</li> <li>Striim - Real-time data integration platform with CDC capabilities.</li> </ul>"},{"location":"cdc/#conclusion","title":"Conclusion","text":"<p>The Change Data Capture pattern is a powerful way to keep your data synchronized across systems in real-time. Whether you\u2019re looking to ensure data consistency in a microservices architecture or trigger events in response to data changes, CDC can make your system more responsive and reliable. Just be mindful of potential pitfalls like tightly coupling your events to the database schema, and you\u2019ll be well on your way to a more resilient system.</p>"},{"location":"command-query-responsibility-segregation/","title":"Command Query Responsibility Segregation (CQRS)","text":"<p>In its most basic form, it's just a separation (segregation) between requests that change data (commands) and requests that query data. For example application 1 handles all the commands and application 2 handles all the queries. Usually because each form has separate performance requirements such as throughput, latency, security, etc.</p> <p>Because read and write happens in different places, one of the drawbacks is having consistency between queries and commands as they lag behind, also called eventual consistency.</p> <p>Application in charge of processing commands:</p> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Command application\",\n    \"description\": \"The application in charge of processing commands\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"AddAddress\": {\n      \"address\": \"/address\",\n      \"messages\": {\n        \"AddressMessage\": {\n          \"$ref\": \"#/components/messages/AddressMessage\"\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"AddNewAddress\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/AddAddress\"\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Address\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"addresses\"\n        ],\n        \"properties\": {\n          \"addresses\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"addressId\",\n                \"addressPurpose\",\n                \"addressLine1\",\n                \"addressLine2\",\n                \"addressTS\"\n              ],\n              \"properties\": {\n                \"addressId\": {\n                  \"type\": \"string\"\n                },\n                \"addressPurpose\": {\n                  \"type\": \"string\"\n                },\n                \"addressLine1\": {\n                  \"type\": \"string\"\n                },\n                \"addressLine2\": {\n                  \"type\": \"string\"\n                },\n                \"addressTS\": {\n                  \"type\": \"number\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"messages\": {\n      \"AddressMessage\": {\n        \"payload\": {\n          \"$ref\": \"#/components/schemas/Address\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Application in charge of processing queries:</p> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Query application\",\n    \"description\": \"The application in charge of processing queries\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"GetAddress\": {\n      \"address\": \"/address\",\n      \"messages\": {\n        \"AddressMessage\": {\n          \"$ref\": \"#/components/messages/AddressMessage\"\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"QueryAddress\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/GetAddress\"\n      }\n    }\n  },\n  \"components\": {\n    ...\n  }\n}\n</code></pre>"},{"location":"command-query-responsibility-segregation/#further-resources","title":"Further resources:","text":"<ul> <li>https://solace.com/event-driven-architecture-patterns/#cqrs</li> <li>https://ibm-cloud-architecture.github.io/refarch-eda/patterns/cqrs/</li> </ul>"},{"location":"dead-letter-queue/","title":"Dead Letter Queue (DLQ)","text":""},{"location":"dead-letter-queue/#introduction","title":"Introduction","text":"<p>In any robust messaging system, failures are inevitable. Messages might be malformed, consumers might crash, or processing logic might fail due to unforeseen data anomalies. To handle such scenarios gracefully, the Dead Letter Queue (DLQ) pattern is employed.</p> <p>The primary challenge addressed by the DLQ pattern is the handling of messages that cannot be processed successfully. Without a mechanism to manage these problematic messages, they can clog the main queue, leading to processing delays and potential system outages. The DLQ pattern ensures that:</p> <ul> <li>Unprocessable messages are isolated: Faulty messages are moved to a separate queue to prevent them from hindering the processing of valid messages.</li> <li>System resilience is enhanced: By offloading problematic messages, the system can continue operating smoothly without manual intervention.</li> <li>Error analysis is facilitated: Storing failed messages allows developers to inspect and understand the root causes of failures.</li> </ul>"},{"location":"dead-letter-queue/#key-concepts","title":"Key Concepts","text":"<ul> <li>Dead Letter Queue (DLQ): A dedicated queue that stores messages which failed to process after a predefined number of attempts.</li> <li>Poison Messages: Messages that consistently cause processing failures due to issues like invalid format or unexpected content.</li> <li>Retry Mechanism: The strategy of reattempting message processing before relegating it to the DLQ.</li> <li>Message Acknowledgment: A confirmation sent by the consumer to the broker indicating successful message processing.</li> <li>Back-off Strategies: Techniques to progressively delay retry attempts, often used to prevent overwhelming a failing service.</li> </ul>"},{"location":"dead-letter-queue/#where-it-can-be-used","title":"Where it can be used ?","text":"<p>The DLQ pattern is applicable in any asynchronous messaging system where message processing reliability is crucial. Common use cases include:</p> <ul> <li>Microservices architectures: Ensuring that one service's failure doesn't cascade to others.</li> <li>Event-driven systems: Handling events that cannot be processed immediately due to temporary issues.</li> <li>Integration platforms: Managing message flows between disparate systems where data inconsistencies might occur.</li> </ul>"},{"location":"dead-letter-queue/#example","title":"Example","text":"<p>Let's consider an e-commerce order processing system that uses a message queue to handle incoming orders. Here's an example of how a Dead Letter Queue might be implemented:</p> <ol> <li> <p>Order Processing:</p> <ul> <li>An order message is received and processed by the <code>OrderProcessor</code> service.</li> <li>The <code>OrderProcessor</code> service validates the order and calculates shipping costs.</li> <li>If the order is valid, it is sent to the <code>ShippingService</code> for further processing.</li> <li>If the order is invalid, it is sent to the DLQ.</li> </ul> </li> <li> <p>Shipping Service:</p> <ul> <li>The <code>ShippingService</code> service receives the order message and attempts to process it.</li> <li>If the order is valid, it is sent to the <code>ShippingService</code> for further processing.</li> <li>If the order is invalid, it is sent to the DLQ.</li> </ul> </li> <li> <p>DLQ:</p> <ul> <li>The DLQ service receives the order message and stores it.</li> <li>The DLQ service also tracks the number of attempts to process the message.</li> <li>If the message has been retried multiple times, it is sent to an external system for manual inspection.</li> </ul> </li> <li> <p>Monitoring and Analysis:</p> <ul> <li>The DLQ service provides an interface for monitoring and analyzing failed messages.</li> <li>Developers can use this interface to understand the root causes of failures and improve the system's reliability.</li> </ul> </li> </ol> <p>This example illustrates how a DLQ can be used to isolate and manage messages that cannot be processed successfully. By implementing this pattern, the e-commerce order processing system can ensure that faulty messages do not affect the processing of valid orders and can be analyzed and resolved to prevent future failures.</p>"},{"location":"dead-letter-queue/#asyncapi-specification","title":"AsyncAPI Specification","text":"<p>Here's an AsyncAPI specification that demonstrates the Dead Letter Queue pattern:</p> <pre><code>asyncapi: 3.0.0\ninfo:\n  title: Order Processing Service\n  version: 1.0.0\nchannels:\n  order/created:\n    address: order/created\n    messages:\n      subscribe.message:\n        $ref: '#/components/messages/OrderCreated'\n  order/dlq:\n    address: order/dlq\n    messages:\n      publish.message:\n        $ref: '#/components/messages/OrderFailed'\noperations:\n  order/created.subscribe:\n    action: send\n    channel:\n      $ref: '#/channels/order~1created'\n    messages:\n      - $ref: '#/channels/order~1created/messages/subscribe.message'\n  order/dlq.publish:\n    action: receive\n    channel:\n      $ref: '#/channels/order~1dlq'\n    messages:\n      - $ref: '#/channels/order~1dlq/messages/publish.message'\ncomponents:\n  messages:\n    OrderCreated:\n      payload:\n        type: object\n        properties:\n          orderId:\n            type: string\n          items:\n            type: array\n            items:\n              type: string\n    OrderFailed:\n      payload:\n        type: object\n        properties:\n          originalMessage:\n            type: object\n          errorDetails:\n            type: string\n</code></pre>"},{"location":"dead-letter-queue/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Infinite Retry Loops: Without a cap on retry attempts, messages can cause endless processing cycles.</li> <li>DLQ Overload: Neglecting DLQ monitoring can lead to storage issues if the queue grows uncontrollably.</li> <li>No Reprocessing Strategy: Failing to plan for DLQ message handling can negate the benefits of capturing failed messages.</li> <li>Security Risks: Storing sensitive data in DLQs without proper encryption or access controls can lead to compliance violations.</li> </ul>"},{"location":"dead-letter-queue/#relations-with-other-patterns","title":"Relations with Other Patterns","text":"<ul> <li>Retry Pattern: Works hand-in-hand with DLQ, allowing systems to attempt processing before giving up.</li> <li>Circuit Breaker Pattern: Prevents a system from repeatedly trying to process messages when a service is known to be down.</li> <li>Fallback Pattern: Provides alternative processing logic when the primary method fails.</li> <li>Message Filtering Pattern: Filters out unprocessable messages early to reduce load on the system.</li> </ul>"},{"location":"dead-letter-queue/#references","title":"References","text":"<ul> <li>Dead Letter Queue</li> <li>Implementing the Dead Letter Queue Pattern in a Microservices Architecture</li> <li>DeadLetterChannel</li> </ul>"},{"location":"dead-letter-queue/#conclusion","title":"Conclusion","text":"<p>The Dead Letter Queue pattern is a critical component in building resilient messaging systems.By understanding and applying the DLQ pattern, developers can create systems that not only handle failures gracefully but also provide avenues for diagnosing and rectifying underlying issues, ultimately leading to more stable and reliable applications.</p>"},{"location":"event-carried-state-transfer/","title":"Event carried state transfer (ECST)","text":"<p>counter parts: Event-notification</p> <p>Instead of simply saying <code>the address of user x has changed</code>, ECST means events carry related information with it, to become more verbose, so it tells exactly what changed <code>user x has a new address y and the old address was z</code>. It is a way of sharing data across systems, so it becomes a question of how much data/information do you want each event to contain? </p> <p>It splits out into two at least 3 approaches, fine grained (Delta events), fine grained snapshots and snapshots (fat events).</p>"},{"location":"event-carried-state-transfer/#fine-grained","title":"Fine grained","text":"<p>Fine grained is the smallest amount of data that can be send using ECST, which simply answers \"what has specifically changed?\".</p> <ul> <li>Good when services each has a copy of the data and just need to apply the change them self</li> </ul> <p>Example for <code>Fine Grained payload</code> structure:</p> <pre><code>{\n  \"addressId\": \"12366\",\n  \"oldState\": {\n    \"addressLine1\": \"84 Baker Street\"\n  },\n  \"newState\": {\n    \"addressLine1\": \"48 Baker Street\"\n  }\n}\n</code></pre>"},{"location":"event-carried-state-transfer/#fine-grained-snapshots","title":"Fine grained snapshots","text":"<p>Fine grained snapshots include a all the information about the object that changed so you always have access to the complete picture in the event.</p> <ul> <li>Good if you debug event streams (without the context of applications) to full picture of the state.</li> </ul> <p>Example for <code>Fine grained snapshots</code> payload structure:</p> <pre><code>{\n  \"addressId\": \"12366\",\n  \"oldState\": {\n    \"addressContent\": {\n      \"addressPurpose\": \"billing\",\n      \"addressLine1\": \"84 Baker Street\",\n      \"addressLine2\": \"London, UK, E1 7AE\",\n      \"addressTS\": 1572134105\n    }\n  },\n  \"newState\": {\n    \"addressContent\": {\n      \"addressPurpose\": \"billing\",\n      \"addressLine1\": \"48 Baker Street\",\n      \"addressLine2\": \"London, UK, E1 7AE\",\n      \"addressTS\": 1572134205\n    }\n  }\n}\n</code></pre>"},{"location":"event-carried-state-transfer/#snapshots","title":"Snapshots","text":"<p>Snapshots take a further step back, and look at the greater object that address belongs to, for example customer, and give you the current snapshot of that state of that object. That way you only need to look at the event itself to know the state of the entity.</p> <p>Example for <code>Snapshot</code> payload structure:</p> <pre><code>{\n  \"customerId\": \"911000100\",\n  \"oldState\": {\n    \"addressContent\": {\n      \"addresses\": [\n        {\n          \"addressId\": \"12366\",\n          \"addressPurpose\": \"billing\",\n          \"addressLine1\": \"84 Baker Street\",\n          \"addressLine2\": \"London, UK, E1 7AE\",\n          \"addressTS\": 1572134105\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"44 Infinite Loop\",\n          \"addressLine2\": \"Cupertino, CA, US, 95014\",\n          \"addressTS\": 1452034105\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"500 George Street\",\n          \"addressLine2\": \"Sydney, NSW, AU, 2000\",\n          \"addressTS\": 1452034105\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"15 Karl-Liebknecht-Str\",\n          \"addressLine2\": \"Berlin, DE, 10318\",\n          \"addressTS\": 1452034105\n        }\n      ]\n    }\n  },\n  \"newState\": {\n    \"addressContent\": {\n      \"addresses\": [\n        {\n          \"addressId\": \"12366\",\n          \"addressPurpose\": \"billing\",\n          \"addressLine1\": \"48 Baker Street\",\n          \"addressLine2\": \"London, UK, E1 7AE\",\n          \"addressTS\": 1572134205\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"44 Infinite Loop\",\n          \"addressLine2\": \"Cupertino, CA, US, 95014\",\n          \"addressTS\": 1452034105\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"500 George Street\",\n          \"addressLine2\": \"Sydney, NSW, AU, 2000\",\n          \"addressTS\": 1452034105\n        },\n        {\n          \"addressId\": \"123124\",\n          \"addressPurpose\": \"shipping\",\n          \"addressLine1\": \"15 Karl-Liebknecht-Str\",\n          \"addressLine2\": \"Berlin, DE, 10318\",\n          \"addressTS\": 1452034105\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"event-carried-state-transfer/#general","title":"General","text":"<p>You must make sure that the consumers are idempotent as processing the same event carries message means that the \"local\" data might change unexpected. Some brokers already have something like this build in if they support exactly-once delivery.</p> <p>As seen in the examples, the more verbose the event becomes, the more complex it is to extract the data and the more expensive it is to send over the wire</p> <p>With more verbose events, the more PII comes into play.</p> <p>You will have eventual-consistency across producer/data owner - and consumers (and even across consumers). \"This inconsistency may only last for a few milliseconds but, in a high-traffic system that sends out thousands of ECS messages, the likelihood of an inconsistent read increases rapidly.\" (https://blogs.mulesoft.com/api-integration/strategy/event-carried-state-messages/)</p> <p>Example AsyncAPI document for a consumer:</p> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Account Service\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"addressChanged\": {\n      \"address\": \"/address\",\n      \"messages\": {\n        \"FineGrained\": {\n          \"$ref\": \"#/components/messages/FineGrained\"\n        },\n        \"FineGrainedSnapshots\": {\n          \"$ref\": \"#/components/messages/FineGrainedSnapshots\"\n        },\n        \"Snapshots\": {\n          \"$ref\": \"#/components/messages/Snapshots\"\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"addressChanged\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/addressChanged\"\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"PartialAddress\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"addressPurpose\": {\n            \"type\": \"string\"\n          },\n          \"addressLine1\": {\n            \"type\": \"string\"\n          },\n          \"addressLine2\": {\n            \"type\": \"string\"\n          },\n          \"addressTS\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"FullAddress\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"addressPurpose\",\n          \"addressLine1\",\n          \"addressLine2\",\n          \"addressTS\"\n        ],\n        \"properties\": {\n          \"addressPurpose\": {\n            \"type\": \"string\"\n          },\n          \"addressLine1\": {\n            \"type\": \"string\"\n          },\n          \"addressLine2\": {\n            \"type\": \"string\"\n          },\n          \"addressTS\": {\n            \"type\": \"number\"\n          }\n        }\n      },\n      \"SnapshotAddress\": {\n        \"type\": \"object\",\n        \"required\": [\n          \"addresses\"\n        ],\n        \"properties\": {\n          \"addresses\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"object\",\n              \"required\": [\n                \"addressId\",\n                \"addressPurpose\",\n                \"addressLine1\",\n                \"addressLine2\",\n                \"addressTS\"\n              ],\n              \"properties\": {\n                \"addressId\": {\n                  \"type\": \"string\"\n                },\n                \"addressPurpose\": {\n                  \"type\": \"string\"\n                },\n                \"addressLine1\": {\n                  \"type\": \"string\"\n                },\n                \"addressLine2\": {\n                  \"type\": \"string\"\n                },\n                \"addressTS\": {\n                  \"type\": \"number\"\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"messages\": {\n      \"FineGrained\": {\n        \"description\": \"Fine grained ESCT pattern, notice the optional properties for the states\",\n        \"payload\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"addressId\": {\n              \"type\": \"string\"\n            },\n            \"oldState\": {\n              \"$ref\": \"#/components/schemas/PartialAddress\"\n            },\n            \"newState\": {\n              \"$ref\": \"#/components/schemas/PartialAddress\"\n            }\n          }\n        }\n      },\n      \"FineGrainedSnapshots\": {\n        \"description\": \"Fine grained snapshot ESCT pattern, notice the required properties for the states\",\n        \"payload\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"addressId\": {\n              \"type\": \"string\"\n            },\n            \"oldState\": {\n              \"$ref\": \"#/components/schemas/FullAddress\"\n            },\n            \"newState\": {\n              \"$ref\": \"#/components/schemas/FullAddress\"\n            }\n          }\n        }\n      },\n      \"Snapshots\": {\n        \"description\": \"Snapshot ESCT pattern, notice the `customerId` in the root, and `addressId` in the state\",\n        \"payload\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"customerId\": {\n              \"type\": \"string\"\n            },\n            \"oldState\": {\n              \"$ref\": \"#/components/schemas/SnapshotAddress\"\n            },\n            \"newState\": {\n              \"$ref\": \"#/components/schemas/SnapshotAddress\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"event-carried-state-transfer/#further-resources","title":"Further resources:","text":"<ul> <li>https://medium.com/swlh/event-notification-vs-event-carried-state-transfer-2e4fdf8f6662</li> <li>https://solace.com/event-driven-architecture-patterns/</li> <li>https://blogs.mulesoft.com/api-integration/strategy/event-carried-state-messages/</li> <li>https://itnext.io/the-event-carried-state-transfer-pattern-aae49715bb7f</li> <li>https://eda-visuals.boyney.io/visuals/eventual-consistency</li> </ul>"},{"location":"event-source/","title":"Event Source","text":"<p>In a nutshell it is the principle of having a stream of events, each describing the change that is happening, similar to Blockchain, just not as rigid. This principle is closely related to fine grained events. This is because that if you lose the current accumulated state, say the state of the customer, if it's event sourced, you should easily be able to recover the customer state using the original source. Event sourcing is usually paired with a broker or a data lake that stores the events for a long time enabling you to recover correctly.</p> <p>Event Source is in its nature append-only, meaning that events once entered the stream cannot change, only be appended. If the data is not append-only, you allow to modify, delete, or reorder those events it would make it an Mutable Event Log. </p> <p></p> <p>NOTICE: Event Source and EventSource, is two different things, the first is a design pattern, the second is a the interface for server-sent-events</p> <p>In AsyncAPI there are no way to describe explicitly you are using event source, except through meta data such as <code>description</code> and <code>summary</code>. However, one might look like the following:</p> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Event source orders\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"EventSourceOrders\": {\n      \"description\": \"Source for orders\",\n      \"address\": \"/orders\",\n      \"messages\": {\n        \"OrderNew\": {\n          \"$ref\": \"#/components/messages/OrderNew\"\n        },\n        \"OrderPaymentReceived\": {\n          \"$ref\": \"#/components/messages/OrderPaymentReceived\"\n        },\n        \"OrderPreparing\": {\n          \"$ref\": \"#/components/messages/OrderPreparing\"\n        },\n        \"OrderShipped\": {\n          \"$ref\": \"#/components/messages/OrderShipped\"\n        }\n      }\n    }\n  },\n  \"components\": {\n    ...\n  }\n}\n</code></pre> <p>Given the above example, we have a channel that contains all the fine grained events that happened for an order, that contains multiple different messages. This is usually paired with a <code>discriminator</code> and correlation id (or topic parameter), so you can easily distinguish between the messages and also between orders. Also notice that there are no final <code>Order</code> message, everything is split out into separate messages that explains changes to an order. To get the final order status, we source the information from this channel.</p> <p>Now all applications will of course be publishing or consuming these messages. For example we might have applications that each separately publish them, say a shipping service, here we simply reuse the channel. </p> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Order processing\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"EventSourceOrders\": {\n      \"$ref\": \"./event-source.json#/channels/EventSourceOrders\"\n    }\n  },\n  \"operations\": {\n    \"OrderShipped\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/EventSourceOrders\"\n      },\n      \"messages\": [\n        {\n          \"$ref\": \"#/channels/EventSourceOrders/messages/OrderShipped\"\n        }\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"event-source/#key-points","title":"Key Points","text":"<ul> <li>The source is always immutable events, meaning to make a change means producing a new event.</li> <li>Because it's immutable events it enables auditing, time traveling (debugging what if), enables easy root cause analysis when something goes down (because everything is traceable).</li> <li>Rebuilding status when services go down, nothing is ever lost.</li> </ul>"},{"location":"event-source/#further-resources","title":"Further resources:","text":"<ul> <li>https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</li> <li>https://developer.mozilla.org/en-US/docs/Web/API/EventSource</li> <li>https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events</li> <li>https://www.eventstore.com/event-sourcing</li> </ul>"},{"location":"glossary/","title":"Glossaries","text":"<p>Many definitions have multiple words defining the same name for the concepts, this glossary sections helps create a common language for the design patterns.</p> <p>Here is the content reformatted into a table for a glossary:</p> Term Definition Usage Delta events Small events that add to previous events, i.e., similar to time since last changed in game development. Used in ECST Fat events A self-contained event that includes most, if not all, information. Used in ECST Idempotent A function is said to be idempotent if multiple calls with the same information never change the outcome. It is similar to stateless in application development. Used in ECST Exactly-once delivery A message pattern that ensures that the consumer(group) only gets the message once, regardless of restarts, etc. Used in ECST PII Personally identifiable information is any information connected to a specific individual that can be used to uncover that individual's identity, such as their social security number, full name, email address, or phone number. Used in ECST Eventual consistency When we build distributed systems, there are times that state is distributed across our architecture (e.g., when we favour availability over consistency, e.g., services have a copy of the data they are consuming vs requesting it from another service). This means data across your architecture in theory will be eventually consistent and at times the state will be inconsistent (as data is replicated across your architecture). Used in ECST Data lake A data lake is a centralized repository designed to store, process, and secure large amounts of structured, semi-structured, and unstructured data. It can store data in its native format and process any variety of it, ignoring size limits. Used in event source Data warehouse See Data lake above. See Data lake above."},{"location":"pattern-example/","title":"This is a pattern example","text":""},{"location":"saga/","title":"Saga pattern","text":"<p>When placing an order, there are likely multiple services in the backend that needs to \"sign-off\" that the purchase went through. For example, a step in the process could be to check that the customer has not reached it's credit limit, and if they have, the transaction needs to be rejected in some fashion. </p> <p>How those long-running transaction is coordinated across multiple microservices, ensuring data consistency and eventual completion is possible through the Saga pattern.</p> <p>There are two saga types, choreograph and orchestration based. The main difference between the two is how the transaction is coordinated and who is responsible for what. </p> <p></p>"},{"location":"saga/#choreograph-based","title":"Choreograph based","text":"<p>Is the decentralized coordination pattern. Each service involved in the transaction is responsible for listening and reacting to events from other services. </p> <p>For example; The payment service performs a payment and emits a \"Payment Successful\" event, which is consumed by the shipping service to trigger shipping. There are no central service that asks the services to perform anything.</p> <p>Notice how the shipping service is receiving when payment is successful on it's own without a single service handling the transaction.</p>  Payment service   Shipping service  <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Payment service\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"PaymentSuccess\": {\n      \"description\": \"Payment was successfully made\",\n      \"address\": \"payment.success\",\n      \"messages\": {\n        \"PaymentSuccess\": {\n          ...\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"PaymentMade\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PaymentSuccess\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Shipping service\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"PaymentSuccess\": {\n      \"description\": \"Payment was successfully made\",\n      \"address\": \"payment.success\",\n      \"messages\": {\n        \"PaymentSuccess\": {\n          ...\n        }\n      }\n    },\n    \"OrderShipped\": {\n      \"description\": \"Order was successfully shipped\",\n      \"address\": \"order.sent\",\n      \"messages\": {\n        \"OrderShipped\": {\n          ...\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"PaymentMade\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PaymentSuccess\"\n      }\n    },\n    \"OrderShipped\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/OrderShipped\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"saga/#orchestration-based","title":"Orchestration based","text":"<p>A Orchestration based Saga is a single service or part of another that ensures that the transaction runs as expected and calls the corresponding services that are part of the transaction. </p> <p>For example; The orchestrator calls when an order is received calls the payment service, and finally the shipping service, controlling the coordination of the transactions.</p> <p>Notice how the Orchestrator are interacting with payment and shipping service and receive and send to both, orchestrating when and what happens. </p>  Orchestrator   Payment service   Shipping service  <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Orchestrator\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"PayForOrder\": {\n      \"description\": \"Make the payment for the order\",\n      \"address\": \"payment.pay\",\n      \"messages\": {\n        \"PaymentPay\": {\n          ...\n        }\n      }\n    },\n    \"PaymentSuccess\": {\n      \"description\": \"Payment was successfully made\",\n      \"address\": \"payment.success\",\n      \"messages\": {\n        \"PaymentSuccess\": {\n          ...\n        }\n      }\n    },\n    \"SendOrder\": {\n      \"description\": \"Send an order\",\n      \"address\": \"order.send\",\n      \"messages\": {\n        \"SendOrder\": {\n          ...\n        }\n      }\n    },\n    \"OrderShipped\": {\n      \"description\": \"Order was successfully shipped\",\n      \"address\": \"order.sent\",\n      \"messages\": {\n        \"OrderShipped\": {\n          ...\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"PayForOrder\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PayForOrder\"\n      }\n    },\n    \"PaymentMade\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PaymentSuccess\"\n      }\n    },\n    \"SendOrder\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/SendOrder\"\n      }\n    },\n    \"OrderShipped\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/OrderShipped\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Payment service\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"PayForOrder\": {\n      \"description\": \"Make the payment for the order\",\n      \"address\": \"payment.pay\",\n      \"messages\": {\n        \"PaymentPay\": {\n          ...\n        }\n      }\n    },\n    \"PaymentSuccess\": {\n      \"description\": \"Payment was successfully made\",\n      \"address\": \"payment.success\",\n      \"messages\": {\n        \"PaymentSuccess\": {\n          ...\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"PayForOrder\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PayForOrder\"\n      }\n    },\n    \"PaymentMade\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/PaymentSuccess\"\n      }\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"asyncapi\": \"3.0.0\",\n  \"info\": {\n    \"title\": \"Shipping service\",\n    \"version\": \"1.0.0\"\n  },\n  \"channels\": {\n    \"SendOrder\": {\n      \"description\": \"Send an order\",\n      \"address\": \"order.send\",\n      \"messages\": {\n        \"SendOrder\": {\n          ...\n        }\n      }\n    },\n    \"OrderShipped\": {\n      \"description\": \"Order was successfully shipped\",\n      \"address\": \"order.sent\",\n      \"messages\": {\n        \"OrderShipped\": {\n          ...\n        }\n      }\n    }\n  },\n  \"operations\": {\n    \"SendOrder\": {\n      \"action\": \"receive\",\n      \"channel\": {\n        \"$ref\": \"#/channels/SendOrder\"\n      }\n    },\n    \"OrderShipped\": {\n      \"action\": \"send\",\n      \"channel\": {\n        \"$ref\": \"#/channels/OrderShipped\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"saga/#final-remarks","title":"Final remarks","text":"<p>The main differences can be seen below;</p> Aspect Choreography Orchestration Control Decentralized, self-coordinated Centralized, orchestrator-controlled Communication Event-driven (publish/subscribe) Direct service invocation Coupling Loosely coupled Loosely coupled, but tightly coupled to the orchestrator Flow Complexity Complex with multiple services Centralized and easier to trace Failure Handling Compensating actions handled individually by services Orchestrator manages compensations Flexibility More flexible and scalable in smaller, simpler use cases Easier to manage in complex workflows <p>For better specifying the exact fail scenarios and workflows, one might take a look at Arazzo.</p>"},{"location":"saga/#resources","title":"Resources","text":"<ul> <li>https://microservices.io/patterns/data/saga.html</li> <li>https://medium.com/cloud-native-daily/microservices-patterns-part-04-saga-pattern-a7f85d8d4aa3</li> <li>https://www.geeksforgeeks.org/saga-design-pattern/</li> </ul>"}]}